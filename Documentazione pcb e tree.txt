Per la creazione e l'implementazione delle funzioni dei pcb e dei tree abbiamo sfruttato i metodi presenti in list.h, non abbiamo fatto uso di funzioni aggiuntive per la risoluzione dei metodi richiesti. Abbiamo implementato la lista dei pcbFree_h come struct list_head e l'array pcbFree_table come array di pcb_t di dimensione MAXPROC.
Per quanto riguarda le funzioni freePcb, mkEmptyProcQ, emptyProcQ, insertProcQ, emptyChild e insertChild ci siamo limitati a poche righe di codice, in quanto i metodi forniti da list.h permettevano una risoluzione abbastanza immediata.
Riguardo a initPcbs inizializziamo la struct list_head pcbFree_h e dopodichè, tramite l'utilizzo di un ciclo while e un controllo sul numero di processi massimi, ne inseriamo all'interno gli elementi della pcbFree_table. 
Per la funzione allocPcb controlliamo inizialmente se la lista pcbFree_h è vuota o meno e in caso
non lo fosse salviamo in un pcb temporaneo il primo elemento, che andiamo a rimuovere, e inizializziamo a 0 o a NULL i campi del pcb tmp che restituiamo.
A proposito delle funzioni headProcQ e removeProcQ sono implementate in modo simile, con l'unica differenza che removeProcQ prevede anche l'eliminazione dell'elemento in testa a head, mentre headProcQ la semplice restituizione dell'elemento di testa.
Relativamente alla funzione outProcQ controlliamo preventivamente se head è vuota, in seguito, nel caso in cui non sia vuota, sfruttiamo una lista temporanea per scorrere head e ad ogni iterazione del ciclo verifichiamo se p (ovvero il pcb puntato da eliminare) è presente e, nel caso in cui lo fosse, lo rimuoviamo dalla lista.
In merito a removeChild controlliamo se il pcb fornito in input ha figli o meno. Nel caso in cui li avesse salviamo il primo figlio in un pcb temporaneo, lo rimuoviamo e lo restituiamo in output.
Riguardo a outChild controlliamo se il pcb puntato da p non ha un padre. Successivamente, con l'ausilio della funzione list_del rimuoviamo il pcb puntato da p dalla lista dei figli del padre, quindi lo restituiamo. 
